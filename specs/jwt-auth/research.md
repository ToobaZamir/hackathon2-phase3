# JWT Authentication Research

## Decision: Database Schema for User Model
- **Rationale**: Need to define proper fields and constraints for the User model
- **Decision**: User model will include id, username, email, hashed_password, is_active, timestamps
- **Fields**:
  - id: Primary key, auto-incrementing integer
  - username: Unique string (3-50 chars)
  - email: Unique string (5-100 chars)
  - hashed_password: String for bcrypt hash
  - is_active: Boolean, defaults to True
  - created_at: DateTime with timezone
  - updated_at: DateTime with timezone, updates on change
- **Alternatives considered**: Alternative field names, different constraints

## Decision: JWT Claims Structure
- **Rationale**: Need to define what information to include in JWT tokens
- **Decision**: Include sub (username), user_id, and exp (expiration) claims
- **Claims**:
  - sub: Subject (username) for identification
  - user_id: Integer user ID for database queries
  - exp: Expiration timestamp (required for security)
- **Alternatives considered**: Including email, roles, or other user data in tokens

## Decision: Password Hashing Algorithm
- **Rationale**: Need secure method for storing passwords
- **Decision**: Use bcrypt via passlib library
- **Implementation**:
  - Algorithm: bcrypt (default for passlib)
  - Rounds: Default (adaptive, ~12 rounds)
  - Salt: Automatically generated by bcrypt
- **Alternatives considered**: Argon2, scrypt (bcrypt chosen for simplicity and security)

## Decision: Token Refresh Mechanism
- **Rationale**: Determine if token refresh is needed
- **Decision**: No refresh tokens for initial implementation (client re-authenticates)
- **Implementation**: Short-lived access tokens (30 min default), client handles re-login
- **Alternatives considered**: Refresh tokens, sliding expiration (rejected for simplicity)

## Decision: CORS Policy for Frontend Integration
- **Rationale**: Need to configure CORS for Better Auth frontend
- **Decision**: Configure CORS to allow frontend origin, Authorization header
- **Implementation**:
  - Allow specific frontend origin (not wildcard in production)
  - Allow Authorization header for JWT transmission
  - Allow credentials if needed for session management
- **Alternatives considered**: Different CORS strategies

## Decision: Rate Limiting for Auth Endpoints
- **Rationale**: Prevent brute force attacks on login/registration
- **Decision**: Basic rate limiting using external service (not implemented in initial version)
- **Implementation**: Plan for integration with rate limiting service later
- **Alternatives considered**: In-app rate limiting, IP blocking

## JWT Best Practices for FastAPI
- Use python-jose for JWT handling
- Store secret key in environment variables
- Use HTTPS in production
- Set appropriate expiration times
- Validate token audience if needed
- Handle token revocation via external service

## SQLAlchemy/SQLModel Patterns for User Models
- Use SQLModel for consistency with existing codebase
- Implement proper relationships with Task model
- Add proper indexes for username and email lookups
- Use proper field constraints and validation

## FastAPI Dependency Injection for Auth Middleware
- Use Depends() with security schemes
- Create reusable authentication dependencies
- Implement proper error handling for auth failures
- Use HTTPBearer for token extraction